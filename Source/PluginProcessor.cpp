/*
  ==============================================================================

    This file was auto-generated by the Jucer!

    It contains the basic startup code for a Juce application.

  ==============================================================================
*/



#include "PluginProcessor.h"
#include "PluginEditor.h"


//==============================================================================
FirstVstAudioProcessor::FirstVstAudioProcessor() : 
lastPlayheadCol(-1),
speed(1),
keyboardComponent (0),
noteToPlay(80),
maxPlayheadColPrecise(0.0),
updateGrid(false)
{
	for (int i=0; i <= 127; i++) {
		isNoteOn[i] = false;
		notePlayedLastPlayheadCol[i] = false;
	}
	// initialize grid
	int numNotesOn = getNumNotesOn();
	grid.resize(numNotesOn);
	for (int x = 0; x < numNotesOn; x++) {	
		grid[x].resize(numNotesOn);
	}
}

FirstVstAudioProcessor::~FirstVstAudioProcessor()
{
}

//==============================================================================
const String FirstVstAudioProcessor::getName() const
{
    return JucePlugin_Name;
}

int FirstVstAudioProcessor::getNumParameters()
{
    return 0;
}

float FirstVstAudioProcessor::getParameter (int index)
{
    return 0.0f;
}

void FirstVstAudioProcessor::setParameter (int index, float newValue)
{
}

const String FirstVstAudioProcessor::getParameterName (int index)
{
    return String::empty;
}

const String FirstVstAudioProcessor::getParameterText (int index)
{
    return String::empty;
}

const String FirstVstAudioProcessor::getInputChannelName (int channelIndex) const
{
    return String (channelIndex + 1);
}

const String FirstVstAudioProcessor::getOutputChannelName (int channelIndex) const
{
    return String (channelIndex + 1);
}

bool FirstVstAudioProcessor::isInputChannelStereoPair (int index) const
{
    return true;
}

bool FirstVstAudioProcessor::isOutputChannelStereoPair (int index) const
{
    return true;
}

bool FirstVstAudioProcessor::acceptsMidi() const
{
#if JucePlugin_WantsMidiInput
    return true;
#else
    return false;
#endif
}

bool FirstVstAudioProcessor::producesMidi() const
{
#if JucePlugin_ProducesMidiOutput
    return true;
#else
    return false;
#endif
}

int FirstVstAudioProcessor::getNumPrograms()
{
    return 0;
}

int FirstVstAudioProcessor::getCurrentProgram()
{
    return 0;
}

void FirstVstAudioProcessor::setCurrentProgram (int index)
{
}

const String FirstVstAudioProcessor::getProgramName (int index)
{
    return String::empty;
}

void FirstVstAudioProcessor::changeProgramName (int index, const String& newName)
{
}

//==============================================================================
void FirstVstAudioProcessor::prepareToPlay (double sampleRate_, int samplesPerBlock)
{
    // Use this method as the place to do any pre-playback
    // initialisation that you need..
	sampleRate = sampleRate_;
	midiCollector.reset (sampleRate);
}

void FirstVstAudioProcessor::releaseResources()
{
    // When playback stops, you can use this as an opportunity to free up any
    // spare memory, etc.
}

void FirstVstAudioProcessor::processBlock (AudioSampleBuffer& buffer, MidiBuffer& midiMessages)
{

	AudioPlayHead::CurrentPositionInfo posInfo;
	if (getPlayHead()!= nullptr && getPlayHead()->getCurrentPosition(posInfo)) {
		lastPosInfo = posInfo;
	}

	updateGrid = updateGrid | updateNoteOns(midiMessages);//, isNoteOn);
	//updateGrid = updateNoteOns(midiMessages);//, isNoteOn);

 	midiMessages.clear();  //this turns off playing notes as they're received

	double ppq = posInfo.ppqPosition;

	double playheadColPrecise = fmod (ppq * speed, 
									  (double) jmax((int) grid.size(), 1) //don't ever want mod 0 performed
									  );
	//jmax used because playheadColPrecise can be 0, setting playheadCol to neg
	int playheadCol = jmax(0, (int)playheadColPrecise);

	//can reset lastPlayheadCol to -1 when totalCol is 0 or 1
	if (grid.size() <= 1) {
		if (playheadColPrecise <= maxPlayheadColPrecise) 
			lastPlayheadCol = -1;
		maxPlayheadColPrecise = playheadColPrecise;
	}

	int numNotesOn = getNumNotesOn();
	bool allNotesJustReleased = numNotesOn == 0 && updateGrid;
	bool spansNextBeat = bufferSpansNextBeat(buffer, posInfo);
	if ((spansNextBeat) &&
	//if (playheadCol != lastPlayheadCol && 
		(numNotesOn != 0 || allNotesJustReleased)) {

		if (updateGrid) {
			//TODO: hard coded to do ascending arpeggio. Generalize
			int numNotesOn = getNumNotesOn();
			grid.resize(numNotesOn);
			for (int x = 0; x < numNotesOn; x++) {	
				grid[x].resize(numNotesOn);
			}
			int gridSpotCounter = 0;
			for (int midiNoteNum=0; midiNoteNum < 127; midiNoteNum++) {
				if (isNoteOn[midiNoteNum]) {
					grid[gridSpotCounter][gridSpotCounter].setNoteNum(midiNoteNum);
					gridSpotCounter++;
				}
			}
			updateGrid = false;

			//needed so playheadCol isn't bigger than the grid
			playheadCol = jmin(numNotesOn, playheadCol);
		}

		lastPlayheadCol = playheadCol;

		double beatsPerSec = posInfo.bpm * speed / 60.0;
		double secPerBeat = 1.0 / beatsPerSec;	

		double playheadOffset = playheadColPrecise - playheadCol;
		int playheadOffsetSamples = playheadOffset * secPerBeat * sampleRate;
		playheadOffsetSamples = jmax (buffer.getNumSamples() - playheadOffsetSamples - 1, 0);

		int numSamplesUntilPlayheadCol = playheadOffsetSamples; //TODO: this not correct yet

		for (int i=0; i < 127; i++) {
			if (notePlayedLastPlayheadCol[i]) {
				MidiMessage noteOffMessage = MidiMessage::noteOff(1, i);
				midiMessages.addEvent(noteOffMessage, 
									  jmax(0, numSamplesUntilPlayheadCol - 10));
				notePlayedLastPlayheadCol[i] = false;
			}
		}

		playheadCol = jmin(playheadCol, (int) grid.size() - 1);  //if the grid has shrunk, make sure doesn't go past grid size
		if (grid.size() != 0) {
			for (int y=0; y < grid[playheadCol].size(); y++) {
				Cell cell = grid[playheadCol][y];
				if (cell.getNoteNum() != -1) {
					MidiMessage noteOnMessage = MidiMessage::noteOn(1, cell.getNoteNum(), (uint8) 100);
					midiMessages.addEvent(noteOnMessage, playheadOffsetSamples);
					notePlayedLastPlayheadCol[cell.getNoteNum()] = true;
				}
			}
		}
	}

	// audio processing...
    for (int channel = 0; channel < getNumInputChannels(); ++channel)
    {
        float* channelData = buffer.getSampleData (channel);

        // ..do something to the data...
    }

    // In case we have more outputs than inputs, we'll clear any output
    // channels that didn't contain input data, (because these aren't
    // guaranteed to be empty - they may contain garbage).
    for (int i = getNumInputChannels(); i < getNumOutputChannels(); ++i)
    {
        buffer.clear (i, 0, buffer.getNumSamples());
    }
}

//==============================================================================
bool FirstVstAudioProcessor::hasEditor() const
{
    return true; // (change this to false if you choose to not supply an editor)
}

AudioProcessorEditor* FirstVstAudioProcessor::createEditor()
{
    return new FirstVstAudioProcessorEditor (this);
}

//==============================================================================
void FirstVstAudioProcessor::getStateInformation (MemoryBlock& destData)
{
    // You should use this method to store your parameters in the memory block.
    // You could do that either as raw data, or use the XML or ValueTree classes
    // as intermediaries to make it easy to save and load complex data.
}

void FirstVstAudioProcessor::setStateInformation (const void* data, int sizeInBytes)
{
    // You should use this method to restore your parameters from this memory block,
    // whose contents will have been created by the getStateInformation() call.
}

//==============================================================================
// This creates new instances of the plugin..
AudioProcessor* JUCE_CALLTYPE createPluginFilter()
{
    return new FirstVstAudioProcessor();
}

vector<vector<Cell> > FirstVstAudioProcessor::getGrid() {
	return grid;
}

int FirstVstAudioProcessor::getLastPlayheadCol() const {
	return lastPlayheadCol;
}

int FirstVstAudioProcessor::getNumNotesOn() {
	int numNotesOn = 0;
	for (int i=0; i < 127; i++) {
		if (isNoteOn[i]) numNotesOn++;
	}

	return numNotesOn;
}

bool FirstVstAudioProcessor::bufferSpansNextBeat(AudioSampleBuffer& buffer, AudioPlayHead::CurrentPositionInfo currentPosInfo) {

	int bufferSize = buffer.getNumSamples();
	double ppq = currentPosInfo.ppqPosition;
	double ppqUntilNextBeat = 1.0 - fmod(ppq * speed, 1);
	int samplesUntilNextBeat = convertPpqToSamples(ppqUntilNextBeat, currentPosInfo);
	return bufferSize >= samplesUntilNextBeat ? true : false;
}

int FirstVstAudioProcessor::convertPpqToSamples(double ppq, AudioPlayHead::CurrentPositionInfo currentPosInfo) {
	int samplesPerBeat = getSamplesPerBeat(currentPosInfo);
	return (ppq * samplesPerBeat);
}

int FirstVstAudioProcessor::getSamplesPerBeat() {
	int returnVal = NULL;

	AudioPlayHead::CurrentPositionInfo currentPosInfo;
	if (getPlayHead()!= nullptr && getPlayHead()->getCurrentPosition(currentPosInfo)) {
		returnVal = getSamplesPerBeat(currentPosInfo);
	}
	
	return returnVal;
}

int FirstVstAudioProcessor::getSamplesPerBeat(AudioPlayHead::CurrentPositionInfo currentPosInfo) {
	double beatsPerSec = currentPosInfo.bpm / 60.0;
	double secPerBeat = 1.0 / beatsPerSec;	
	return ((int) (secPerBeat * sampleRate));
}

bool FirstVstAudioProcessor::updateNoteOns(MidiBuffer midiBuffer){//, bool noteOn[]) {
//bool FirstVSTAudioProcessor::updateNoteOns(MidiBuffer midiBuffer) {
	bool shouldUpdate = false;

	MidiBuffer::Iterator midiIterator (midiBuffer);
    MidiMessage m (0xf4, 0.0);
	int midiEventSamplePos;
	bool useEvent = midiIterator.getNextEvent(m, midiEventSamplePos);
	while(useEvent) {
		if (m.isNoteOn()) {
			isNoteOn[m.getNoteNumber()] = true;
			shouldUpdate = true;
		}
		else if (m.isNoteOff()) {
			isNoteOn[m.getNoteNumber()] = false;
			shouldUpdate = true;
		}

		useEvent = midiIterator.getNextEvent(m, midiEventSamplePos);
	}

	return shouldUpdate;
}