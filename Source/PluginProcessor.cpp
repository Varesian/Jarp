/*
  ==============================================================================

    This file was auto-generated by the Jucer!

    It contains the basic startup code for a Juce application.

  ==============================================================================
*/

#include "PluginProcessor.h"
#include "PluginEditor.h"

//==============================================================================
FirstVstAudioProcessor::FirstVstAudioProcessor() : 
sustainNotes(true),
speed(1),
keyboardComponent (0),
noteToPlay(80),
maxPlayheadColPrecise(0.0),
updateGrid(false)
{
	for (int i=0; i <= 127; i++) {
		isNoteOn[i] = false;
		wasNoteOn[i] = false;
		shouldSendNoteOff[i] = false;
		startSustainedNote[i] = false;
	}
	// initialize grid
	int numNotesOn = getNumNotesOn();
	grid.resize(numNotesOn);
	for (int x = 0; x < numNotesOn; x++) {	
		grid[x].resize(numNotesOn);
	}
}

FirstVstAudioProcessor::~FirstVstAudioProcessor()
{
}

//==============================================================================
const String FirstVstAudioProcessor::getName() const
{
    return JucePlugin_Name;
}

int FirstVstAudioProcessor::getNumParameters()
{
    return 0;
}

float FirstVstAudioProcessor::getParameter (int index)
{
    return 0.0f;
}

void FirstVstAudioProcessor::setParameter (int index, float newValue)
{
}

const String FirstVstAudioProcessor::getParameterName (int index)
{
    return String::empty;
}

const String FirstVstAudioProcessor::getParameterText (int index)
{
    return String::empty;
}

const String FirstVstAudioProcessor::getInputChannelName (int channelIndex) const
{
    return String (channelIndex + 1);
}

const String FirstVstAudioProcessor::getOutputChannelName (int channelIndex) const
{
    return String (channelIndex + 1);
}

bool FirstVstAudioProcessor::isInputChannelStereoPair (int index) const
{
    return true;
}

bool FirstVstAudioProcessor::isOutputChannelStereoPair (int index) const
{
    return true;
}

bool FirstVstAudioProcessor::acceptsMidi() const
{
#if JucePlugin_WantsMidiInput
    return true;
#else
    return false;
#endif
}

bool FirstVstAudioProcessor::producesMidi() const
{
#if JucePlugin_ProducesMidiOutput
    return true;
#else
    return false;
#endif
}

int FirstVstAudioProcessor::getNumPrograms()
{
    return 0;
}

int FirstVstAudioProcessor::getCurrentProgram()
{
    return 0;
}

void FirstVstAudioProcessor::setCurrentProgram (int index)
{
}

const String FirstVstAudioProcessor::getProgramName (int index)
{
    return String::empty;
}

void FirstVstAudioProcessor::changeProgramName (int index, const String& newName)
{
}

//==============================================================================
void FirstVstAudioProcessor::prepareToPlay (double sampleRate_, int samplesPerBlock)
{
    // Use this method as the place to do any pre-playback
    // initialisation that you need..
	sampleRate = sampleRate_;
	midiCollector.reset (sampleRate);
}

void FirstVstAudioProcessor::releaseResources()
{
    // When playback stops, you can use this as an opportunity to free up any
    // spare memory, etc.
}

void FirstVstAudioProcessor::processBlock (AudioSampleBuffer& buffer, MidiBuffer& midiMessages)
{

	AudioPlayHead::CurrentPositionInfo posInfo;
	if (getPlayHead()!= nullptr && getPlayHead()->getCurrentPosition(posInfo)) {
		lastPosInfo = posInfo;
	}


	//update the array recording note-ons and remember if grid should be updated
	updateGrid = updateGrid | updateNoteOns(midiMessages);

	midiMessages.clear();  //this turns off playing notes as they're received

	int numNotesOn = getNumNotesOn();
	bool allNotesJustReleased = numNotesOn == 0 && updateGrid;
	bool spansNextBeat = bufferSpansNextBeat(buffer, posInfo);
	if (spansNextBeat && (numNotesOn != 0 || allNotesJustReleased)) {

		double ppq = posInfo.ppqPosition;
		double playheadColPrecise = fmod (ppq * speed, 
										  (double) jmax((int) grid.size(), 1) //don't ever want mod 0 performed
										  );
		int playheadCol = (int) playheadColPrecise;

		if (updateGrid) {
			AscendingPattern pattern = AscendingPattern();
			pattern.buildCells(isNoteOn, grid);

			updateGrid = false;

			//needed so playheadCol isn't bigger than the grid
			playheadCol = jmin(numNotesOn, playheadCol);
		}

		lastPlayheadCol = playheadCol;

		double beatsPerSec = posInfo.bpm * speed / 60.0;
		double secPerBeat = 1.0 / beatsPerSec;

		int numSamplesUntilPlayheadCol = getSamplesToNextBeat(buffer, posInfo);

		for (int i=1; i < 127; i++) {
			if (shouldSendNoteOff[i]) {
				MidiMessage noteOffMessage = MidiMessage::noteOff(1, i);
				midiMessages.addEvent(noteOffMessage, 
									  jmax(0, numSamplesUntilPlayheadCol - 10));
				shouldSendNoteOff[i] = false;
			} 
		}
	
		playheadCol = jmin(playheadCol, (int) grid.size() - 1);  //if the grid has shrunk, make sure doesn't go past grid size
		if (grid.size() != 0) {
			for (int y=0; y < (int) grid[playheadCol].size(); y++) {
				Cell cell = grid[playheadCol][y];
				if (cell.getNoteNum() != -1) {
					if (!sustainNotes) {
						MidiMessage noteOnMessage = MidiMessage::noteOn(1, cell.getNoteNum(), (uint8) 100);
						midiMessages.addEvent(noteOnMessage, numSamplesUntilPlayheadCol - 1);
						shouldSendNoteOff[cell.getNoteNum()] = true;
					} else {
						if (isNoteOn[cell.getNoteNum()] && startSustainedNote[cell.getNoteNum()]) {
							MidiMessage noteOnMessage = MidiMessage::noteOn(1, cell.getNoteNum(), (uint8) 100);
							midiMessages.addEvent(noteOnMessage, numSamplesUntilPlayheadCol - 1);
							startSustainedNote[cell.getNoteNum()] = false;
						}
					}
				}
			}
		}
	}

	for (int i = 1; i < 127; i++) {
		wasNoteOn[i] = isNoteOn[i];
	}

    // In case we have more outputs than inputs, we'll clear any output
    // channels that didn't contain input data, (because these aren't
    // guaranteed to be empty - they may contain garbage).
    for (int i = getNumInputChannels(); i < getNumOutputChannels(); ++i)
    {
        buffer.clear (i, 0, buffer.getNumSamples());
    }
}

//==============================================================================
bool FirstVstAudioProcessor::hasEditor() const
{
    return true; // (change this to false if you choose to not supply an editor)
}

AudioProcessorEditor* FirstVstAudioProcessor::createEditor()
{
    return new FirstVstAudioProcessorEditor (this);
}

//==============================================================================
void FirstVstAudioProcessor::getStateInformation (MemoryBlock& destData)
{
    // You should use this method to store your parameters in the memory block.
    // You could do that either as raw data, or use the XML or ValueTree classes
    // as intermediaries to make it easy to save and load complex data.
}

void FirstVstAudioProcessor::setStateInformation (const void* data, int sizeInBytes)
{
    // You should use this method to restore your parameters from this memory block,
    // whose contents will have been created by the getStateInformation() call.
}

//==============================================================================
// This creates new instances of the plugin..
AudioProcessor* JUCE_CALLTYPE createPluginFilter()
{
    return new FirstVstAudioProcessor();
}

vector<vector<Cell> > FirstVstAudioProcessor::getGrid() {
	return grid;
}

int FirstVstAudioProcessor::getLastPlayheadCol() const {
	return lastPlayheadCol;
}

int FirstVstAudioProcessor::getNumNotesOn() {
	int numNotesOn = 0;
	for (int i=1; i < 127; i++) {
		if (isNoteOn[i]) numNotesOn++;
	}

	return numNotesOn;
}

bool FirstVstAudioProcessor::bufferSpansNextBeat(AudioSampleBuffer& buffer, AudioPlayHead::CurrentPositionInfo currentPosInfo) {

	int bufferSize = buffer.getNumSamples();
	int samplesUntilNextBeat = getSamplesToNextBeat(buffer, currentPosInfo);
	return bufferSize >= samplesUntilNextBeat ? true : false;
}

int FirstVstAudioProcessor::convertPpqToSamples(double ppq, AudioPlayHead::CurrentPositionInfo currentPosInfo) {
	int samplesPerBeat = getSamplesPerBeat(currentPosInfo);
	return ((int) (ppq * samplesPerBeat));
}

int FirstVstAudioProcessor::getSamplesPerBeat() {
	int returnVal = NULL;

	AudioPlayHead::CurrentPositionInfo currentPosInfo;
	if (getPlayHead()!= nullptr && getPlayHead()->getCurrentPosition(currentPosInfo)) {
		returnVal = getSamplesPerBeat(currentPosInfo);
	}
	
	return returnVal;
}

int FirstVstAudioProcessor::getSamplesPerBeat(AudioPlayHead::CurrentPositionInfo currentPosInfo) {
	double beatsPerSec = currentPosInfo.bpm / 60.0;
	double secPerBeat = 1.0 / beatsPerSec;	
	return ((int) (secPerBeat * sampleRate));
}

bool FirstVstAudioProcessor::updateNoteOns(MidiBuffer midiBuffer){
	bool shouldUpdate = false;

	MidiBuffer::Iterator midiIterator (midiBuffer);
    MidiMessage m (0xf4, 0.0);
	int midiEventSamplePos;
	bool useEvent = midiIterator.getNextEvent(m, midiEventSamplePos);
	while(useEvent) {
		if (m.isNoteOn()) {
			if (sustainNotes) {
				shouldSendNoteOff[m.getNoteNumber()] = false;
				if (isNoteOn[m.getNoteNumber()] == false)
					startSustainedNote[m.getNoteNumber()] = true;
			}
			isNoteOn[m.getNoteNumber()] = true;
			shouldUpdate = true;
		}
		else if (m.isNoteOff()) {
			if (sustainNotes) {
				shouldSendNoteOff[m.getNoteNumber()] = true;
				//if note was flipped on between beat, indicate not to trigger a sustained play
				if (isNoteOn[m.getNoteNumber()] == true)
					startSustainedNote[m.getNoteNumber()] = false;
			}
			isNoteOn[m.getNoteNumber()] = false;
			shouldUpdate = true;
		}

		useEvent = midiIterator.getNextEvent(m, midiEventSamplePos);
	}

	return shouldUpdate;
}

int FirstVstAudioProcessor::getSamplesToNextBeat(AudioSampleBuffer& buffer, AudioPlayHead::CurrentPositionInfo currentPosInfo) {

	int bufferSize = buffer.getNumSamples();
	double ppq = currentPosInfo.ppqPosition;
	double ppqUntilNextBeat = 1.0 - fmod(ppq * speed, 1);
	return convertPpqToSamples(ppqUntilNextBeat, currentPosInfo);
}
